import java.util.Enumeration;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.Set;


public class Apriori {
	/***
	 * The TRANSACTIONS 2-dimensional array holds the full data set for the lab
	 */
    static final int[][] TRANSACTIONS = new int[][] { { 1, 2, 3, 4, 5 }, { 1, 3, 5 }, { 2, 3, 5 }, { 1, 5 }, { 1, 3, 4 }, { 2, 3, 5 }, { 2, 3, 5 },
                    { 3, 4, 5 }, { 4, 5 }, { 2 }, { 2, 3 }, { 2, 3, 4 }, { 3, 4, 5 } };

    public static void main( String[] args ) throws Exception {
        // TODO: Select a reasonable support threshold via trial-and-error. Can either be percentage or absolute value.
        
    	
    	System.out.println("TRANSACTIONS Count: " + TRANSACTIONS.length);
    	
    	final int supportThreshold = 5;
        apriori( TRANSACTIONS, supportThreshold );
    }

    public static List<ItemSet> apriori( int[][] transactions, int supportThreshold ) throws Exception {
        int k;
        Hashtable<ItemSet, Integer> frequentItemSets = generateFrequentItemSetsLevel1( transactions, supportThreshold );
        
        frequentItemSets = generateFrequentItemSets( supportThreshold, transactions, frequentItemSets );
        
        /*for (k = 1; frequentItemSets.size() > 0; k++) {
            System.out.print( "Finding frequent itemsets of length " + (k + 1) + "â€¦" );
            frequentItemSets = generateFrequentItemSets( supportThreshold, transactions, frequentItemSets );
            // TODO: add to list

            System.out.println( " found " + frequentItemSets.size() );
        }*/
        // TODO: create association rules from the frequent itemsets

        // TODO: return something useful
        return null;
    }

    private static Hashtable<ItemSet, Integer> generateFrequentItemSets( int supportThreshold, int[][] transactions,
                    Hashtable<ItemSet, Integer> lowerLevelItemSets ) throws Exception {
        // TODO: first generate candidate itemsets from the lower level itemsets
    	
    	int k = lowerLevelItemSets.keySet().size();
    	Hashtable<ItemSet, Integer> candidates = new Hashtable<ItemSet, Integer>();
    	for (ItemSet itemset: lowerLevelItemSets.keySet()){
    		for (ItemSet itemset2: lowerLevelItemSets.keySet()){
    			ItemSet joined = joinSets(itemset,itemset2);
    			if (joined != null){
    				if (!candidates.containsKey(joined))
    					candidates.put(joined, 0);
    			}
    		}
    	}
    	
    	//Print
    	for(ItemSet itemset: candidates.keySet()){
    		System.out.println(itemset + ": " + candidates.get(itemset));
    	}
    	
        /*
         * TODO: now check the support for all candidates and add only those
         * that have enough support to the set
         */

        // TODO: return something useful
        return null;
    }

    private static ItemSet joinSets( ItemSet first, ItemSet second ) throws Exception {
        if (first.set.length != second.set.length)
        	throw new Exception("Sets must be from the same size.");
        int k = first.set.length;
        int[] set = new int[k+1];
        System.out.println("k: " + k);
        for (int i = 0; i < k-1; i++){
        	System.out.println("i: " + i);
        	if (first.set[i] == second.set[i]){
        		set[i] = first.set[i];
        		System.out.println("X: " + new ItemSet(set));
        	}
        	else{
        		set = null;
        		break;
        	}
        }
        if (set != null){
        	set[k] = second.set[k-2];
        	return new ItemSet(set);
        } else
        	return null;
    }

    private static Hashtable<ItemSet, Integer> generateFrequentItemSetsLevel1( int[][] transactions, int supportThreshold ) {
        // TODO: return something useful
    	Hashtable<ItemSet, Integer> tempFrequentItemSetL1 = new Hashtable<ItemSet, Integer>();
    	Hashtable<ItemSet, Integer> frequentItemSetL1 = new Hashtable<ItemSet, Integer>();
    	
    	for(int[] itemset: transactions){
    		for(int item: itemset){
    			ItemSet newItemSet = new ItemSet(new int[]{item});
    			if (frequentItemSetL1.containsKey(newItemSet)){
    				int count = frequentItemSetL1.get(newItemSet) + 1;
    				frequentItemSetL1.put(newItemSet, count);
    			}
    			else
    			{
    				if (tempFrequentItemSetL1.containsKey(newItemSet)){
        				int count = tempFrequentItemSetL1.get(newItemSet) + 1;
        				if (count >= supportThreshold)
        					frequentItemSetL1.put(newItemSet, count);
        				else
        					tempFrequentItemSetL1.put(newItemSet, count);
    				}
    				else
    				{
    					tempFrequentItemSetL1.put(newItemSet, 1);
    				}
    			}
    		}
    	}
    	
    	//Print
    	for(ItemSet itemset: frequentItemSetL1.keySet()){
    		System.out.println(itemset + ": " + frequentItemSetL1.get(itemset));
    	}
    	
        return frequentItemSetL1;
    }

    private static int countSupport( int[] itemSet, int[][] transactions ) {
        // Assumes that items in ItemSets and transactions are both unique

        // TODO: return something useful
        return 0;
    }

}
